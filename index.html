<!DOCTYPE html>
<html lang="en">
	<head>
		<title>SpinControls Demo</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				margin: 0px;
				background-color: #000000;
				color: #fff;
				font-family:Monospace;
				text-align: center;
				font-size: 15px;
				line-height: 30px;
				overflow: hidden;
			}
			
			#info {
				position: absolute;
				top: 0px; width: 100%;
				padding: 15px;
				z-index:100;
				box-sizing: border-box;
				pointer-events: none;
			}

			.clickable {
				pointer-events: auto;
			}
			
		</style>
	</head>
	<body>

		<div id="info">
			<p><strong>Spin Controls</strong> Left click or touch spheres to rotate them as if touching a trackball.</p>
			<p><strong>Camera</strong> | Orbit: Left click / 1 finger | Pan: Right click / 2 fingers | Zoom: Mouse wheel / pinch</p>
			<p>
				<label for="mapping">Pointer to trackball sphere mapping method: 
					<select id="spin-mapping" class="clickable">
						<option value="raycast">Raycast</option>
						<option value="holroyd">Holroyd</option>
						<option value="shoemake">Shoemake</option>
						<option value="azimuthal">Azimuthal</option>
					</select>
				</label>
				<label for="relatively-spin-off-trackball">Relatively spin off trackball:
					<input type="checkbox" id="relatively-spin-off-trackball" class="clickable" checked/>
				</label>
				<label for="pointer-pivot">Camera trackball at pointer:
					<input type="checkbox" id="pointer-pivot" class="clickable" checked/>
				</label>
			</p>
		</div>

		<!-- <script src="three.min.js"></script> -->
		<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r124/three.min.js"></script>
		<script src="SpinControls.js"></script>
		<script src="CameraSpinControls.js"></script> <!-- CameraSpinControls after SpinControls please -->

		<script>
			var camera, scene, renderer, 
				smallSpinner, bigSpinner, spinControlBig, spinControlSmall, interactives,
				controls, trackballWidget, isTouched, spinners, mapperSelector, relativelySpinCheckbox;
			init();
      		animate( 0 );
      
			function init() {

				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );
        
				camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 10000 );
        		camera.position.set( 600, 300, 600 );
				camera.lookAt( 0, 0, 0 );

				scene = new THREE.Scene();

				scene.add( new THREE.GridHelper( 1000, 4 ) );

				var light = new THREE.DirectionalLight( 0xffffff, 2 );
				light.position.set( 1, 1, -1 );
				scene.add( light );
				
				window.addEventListener( 'mousedown', onMouseDown, true ); // get event first to enable the correct control
				window.addEventListener( 'mouseup', onMouseUp, false ); // get event last, so false on capture
				window.addEventListener( 'wheel', onMouseWheel, true );
				window.addEventListener( 'wheel', onMouseWheelOff, false );
				
				renderer.domElement.addEventListener( 'touchstart', onTouchStart, false );
				window.addEventListener( 'touchend', onTouchEnd, false ); // get event last, so false on capture

				// Spheres to spin
				var radius = 50;
				smallSpinner = new THREE.Group();
				smallSpinner.position.set(200, 0, 300);
				var spinAxis = new THREE.Vector3( 0, 1, 0 );
				var material = new THREE.LineBasicMaterial({
					color: 0xff0000
				});
				var geometry = new THREE.Geometry();
				geometry.vertices.push(
					new THREE.Vector3().copy( spinAxis ).multiplyScalar( radius * 1.2 ),
					new THREE.Vector3().copy( spinAxis ).multiplyScalar( radius * -1.2 )
				);
				var line = new THREE.Line( geometry, material );
				smallSpinner.add( line );
				var geometry = new THREE.SphereBufferGeometry( radius, 16, 16 );
				var lineMaterial = new THREE.LineBasicMaterial( { color: 0xffffff, transparent: true, opacity: 0.2 } );
				smallSpinner.add( new THREE.LineSegments( geometry, lineMaterial ) );				
				var meshMaterial = new THREE.MeshPhongMaterial( { color: 0x333333FF, emissive: 0x072534, side: THREE.DoubleSide, flatShading: true } );
				smallSpinner.sphere = new THREE.Mesh( geometry, meshMaterial );
        		smallSpinner.add( smallSpinner.sphere );
				scene.add( smallSpinner );
				
				spinControlSmall = new SpinControls( smallSpinner, radius, camera, renderer.domElement );
				spinControlSmall.spinAxisConstraint = spinAxis;
        
				var radius = 200;
				bigSpinner = new THREE.Group();
				bigSpinner.position.set(-220, 0, 150);
				var geometry = new THREE.SphereBufferGeometry( radius, 16, 16 );
				var lineMaterial = new THREE.LineBasicMaterial( { color: 0xffffff, transparent: true, opacity: 0.2 } );
				bigSpinner.add( new THREE.LineSegments( geometry, lineMaterial ) );
				var meshMaterial = new THREE.MeshPhongMaterial( { color: 0x156289, emissive: 0x072534, side: THREE.DoubleSide, flatShading: true } );        
				bigSpinner.sphere = new THREE.Mesh( geometry, meshMaterial );
        		bigSpinner.add( bigSpinner.sphere );
				bigSpinner.add( new THREE.Mesh( geometry, meshMaterial ) );
        		scene.add( bigSpinner );
        
        		spinControlBig = new SpinControls( bigSpinner, radius, camera, renderer.domElement);

				// Model to raycast the camera trackball pivot on
				var geometry = new THREE.TorusKnotBufferGeometry( 150, 30, 150, 16 );
				var material = new THREE.MeshNormalMaterial();
				var torusKnot = new THREE.Mesh( geometry, material );
				torusKnot.position.set(200, 0, 0);
				scene.add( torusKnot );
        
				// Camera control UI
				trackballWidget = new THREE.Group();
				trackballWidget.position.set(0, 0, 0);
				var geometry = new THREE.SphereBufferGeometry( 1, 8, 8 );
				meshMaterial = new THREE.MeshBasicMaterial( { color: 0xaaaaff, flatShading: true, transparent: true, opacity: 0.2 } );
				lineMaterial = new THREE.LineBasicMaterial( { color: 0xffffff, transparent: true, opacity: 0.5 } );
				trackballWidget.add( new THREE.LineSegments( geometry, lineMaterial ) );
				trackballWidget.add( new THREE.Mesh( geometry, meshMaterial ) );
				scene.add( trackballWidget );
				trackballWidget.visible = false;
				trackballWidget.renderOrder = 1; // Don't draw to early, thus obscuring other transparent objects        
				
				controls = new CameraSpinControls( camera, renderer.domElement );
				controls.isTargetOffCenter = true;
				
				var cameraPivotSurfaces = [ torusKnot ];

				var raycaster = new THREE.Raycaster();
				var pointerPos = new THREE.Vector2();
				 
				function onMouseMove( event ) {

					pointerPos.x = ( event.clientX / window.innerWidth ) * 2 - 1;
					pointerPos.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

				}

				window.addEventListener( 'mousemove', onMouseMove, false );

				function onPointerDown() {

					if (controls.isTargetOffCenter) {

						raycaster.setFromCamera( pointerPos, camera );
						var intersects = raycaster.intersectObjects( cameraPivotSurfaces );					

						if(intersects.length) {

							controls.setTargetPosition(intersects[0].point);

						} else {

							// Move trackball to center of screen if not clicking on anything.
							// Comment out to rotate with trackball centered on mouse.
							controls.target.set(0, 0, -controls.distanceFromPivot);
							controls.target.applyQuaternion(camera.quaternion);
							controls.target.add(camera.position);
							controls.setTargetPosition(controls.target);

						}

					}

				}

				window.addEventListener( 'mousedown', onPointerDown, true );

				function touchStart( event ) {

					pointerPos.x = ( event.touches[ 0 ].clientX / window.innerWidth ) * 2 - 1;
					pointerPos.y = - ( event.touches[ 0 ].clientY / window.innerHeight ) * 2 + 1;
					onPointerDown();

				}

				window.addEventListener( 'touchstart', touchStart, true );

				function updateCameraSpinUI() {

					trackballWidget.position.copy( controls.target );
					var r = controls.spinControl.trackballRadius;
					trackballWidget.scale.set( r, r, r );

				}

				controls.addEventListener( 'start', function ( event ) {
					
					if (event.state === controls.STATE.DOLLY) {

						if (controls.isTargetOffCenter) {

							// Center trackball on cursor so dolly/zoom moves in mouse direction.
							// Clamp min/max zoom distance by placing trackball at intersection point.
							// Only useful if CameraSpinControls.minDistance/maxDistance set.
							raycaster.setFromCamera( pointerPos, camera );
							var intersects = raycaster.intersectObjects( cameraPivotSurfaces );

							if(intersects.length) {

								controls.setTargetPosition(intersects[0].point);

							} else {

								controls.target.copy(raycaster.ray.direction);
								controls.target.setLength(controls.distanceFromPivot);
								controls.target.add(raycaster.ray.origin);
								controls.setTargetPosition(controls.target);

							}

						}

					} else {

						// Don't turn on trackball graphics for dolly
						trackballWidget.visible = true;
						updateCameraSpinUI();

					}

				} );

				controls.addEventListener( 'change', function ( event ) {

					updateCameraSpinUI();

				} );
				
				controls.addEventListener( 'end', function ( event ) {

					if (event.state !== controls.STATE.DOLLY) {
						
						// Don't turn off if dolly as may still be clicking with pointer
						trackballWidget.visible = false;
						
					}

				} );

				// Pick which control gets to react to input.
				// Raycast pointer to pick which sphere, else camera controls.
				interactives = [ smallSpinner.sphere, bigSpinner.sphere, ...cameraPivotSurfaces ];	
				spinControlSmall.enabled = false;
				spinControlBig.enabled = false;
				controls.enabled = false;
				
				function onMouseDown( event ) {

					if ( event.button === 0 ) {

						pickControlToEnable( getPointerInNdc( event.pageX, event.pageY ) );

					}	else { //if not left click then move camera

						controls.enabled = true;

					}
					
				}

				function onMouseUp( event ) {

					spinControlSmall.enabled = false;
					spinControlBig.enabled = false;
					controls.enabled = false;

				}

				function onMouseWheel( event ) {

					controls.enabled = true;

				}
				function onMouseWheelOff( event ) {

					controls.enabled = false;

				}

				spinners = [spinControlSmall, spinControlBig, controls.spinControl];

				mapperSelector = document.getElementById('spin-mapping');
				mapperSelector.addEventListener("change", onSpinMapping);

				relativelySpinCheckbox = document.getElementById('relatively-spin-off-trackball');
				relativelySpinCheckbox.addEventListener("change", onRelativelySpinOffTrackball);	
				
				var pointerPivot = document.getElementById('pointer-pivot');
				pointerPivot.addEventListener("change", function onPointerPivot() {

					controls.isTargetOffCenter = pointerPivot.checked;

				});
				
				window.addEventListener( 'resize', onWindowResize, false );

			}

			var pickControlToEnable = ( function () {

				var raycaster = new THREE.Raycaster();
				
				var resultArray = [];

				return function pickControlToEnable( pointerNDC ) {

					raycaster.setFromCamera(pointerNDC, camera);
					resultArray.length = 0;
					raycaster.intersectObjects(interactives, false, resultArray);

					if( resultArray.length > 0 ) {

						if( resultArray[0].object === smallSpinner.sphere ) {

							spinControlSmall.enabled = true;

						} else if( resultArray[0].object === bigSpinner.sphere ) {

							spinControlBig.enabled = true;

						} else {

							// Hit static model we want to set pivot point on
							controls.enabled = true;

						}

					} else {

						controls.enabled = true;

					}

				}

			}() );
      
			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();        
				renderer.setSize( window.innerWidth, window.innerHeight );				
				updateCanvas();
        		spinControlSmall.onWindowResize();
				spinControlBig.onWindowResize();
				controls.onWindowResize();
				render();

			}
      
      		function animate(timeStamp) {

				requestAnimationFrame( animate );			
        		spinControlSmall.update();	
				spinControlBig.update();
       			controls.update();
				render();
				
			}
      
			function render() {

				renderer.render( scene, camera );
				
			}

			var canvas = {};
			function updateCanvas() {

				if ( renderer.domElement === document ) {

					canvas.left = 0;
					canvas.top = 0;
					canvas.width = window.innerWidth;
					canvas.height = window.innerHeight;

				} else {

					var box = renderer.domElement.getBoundingClientRect();
					var d = renderer.domElement.ownerDocument.documentElement;
					canvas.left = box.left + window.pageXOffset - d.clientLeft;
					canvas.top = box.top + window.pageYOffset - d.clientTop;
					canvas.width = box.width;
					canvas.height = box.height;

				}

			}

			updateCanvas();

			var getPointerInNdc = ( function () {

				var vector = new THREE.Vector2();

				return function getPointerInNdc( pageX, pageY ) {

					vector.set(
						( ( pageX - canvas.width * 0.5 - canvas.left ) / ( canvas.width * 0.5 ) ),
						( ( canvas.height + 2 * ( canvas.top - pageY ) ) / canvas.height )
					);

					return vector;

				};

			}() );

			function onTouchStart( event ) {

				if ( !isTouched ) {

					isTouched = true;
					pickControlToEnable( getPointerInNdc( event.changedTouches[ 0 ].pageX, event.changedTouches[ 0 ].pageY ) );

				}

			}

			function onTouchEnd( event ) {

				if( event.touches.length === 0 ) {
					
					spinControlSmall.enabled = false;
					spinControlBig.enabled = false;
					controls.enabled = false;
					isTouched = false;

				}

			}

			function onSpinMapping() {

				var mappingMode = mapperSelector.options[mapperSelector.selectedIndex].value;
				var newMode;
				if( mappingMode === 'holroyd' ) {

					newMode = spinControlBig.POINTER_SPHERE_MAPPING.HOLROYD;

				} else if( mappingMode === 'shoemake' ) {

					newMode = spinControlBig.POINTER_SPHERE_MAPPING.SHOEMAKE;

				} else if( mappingMode === 'azimuthal' ) {

					newMode = spinControlBig.POINTER_SPHERE_MAPPING.AZIMUTHAL;

				} else if( mappingMode === 'raycast' ) {

					newMode = spinControlBig.POINTER_SPHERE_MAPPING.RAYCAST;

				}
				
				spinners.forEach((spinner) => {

					spinner.rotateAlgorithm = newMode;

				});
				
			}

			function onRelativelySpinOffTrackball() {

				spinners.forEach((spinner) => {

					spinner.relativelySpinOffTrackball = relativelySpinCheckbox.checked;

				});
				
			}

		</script>

	</body>
</html>